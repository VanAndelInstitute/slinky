% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slinky_sumexp.R
\docType{methods}
\name{loadL1K}
\alias{loadL1K}
\alias{loadL1K,Slinky-method}
\title{loadL1K}
\usage{
loadL1K(x, ids = character(), pert = character(),
  cell_line = character(), type = NULL, where_clause = character(),
  gold = TRUE, inferred = TRUE, fields = character(),
  controls = FALSE, cl = NULL, verbose = FALSE)

\S4method{loadL1K}{Slinky}(x, ids = character(), pert = character(),
  cell_line = character(), type = NULL, where_clause = character(),
  gold = FALSE, inferred = TRUE, fields = character(),
  controls = FALSE, cl = NULL, verbose = FALSE)
}
\arguments{
\item{x}{A slinky object}

\item{ids}{distil_ids to include in the Expression Set.}

\item{pert}{name (pert_iname) of perturbation for which data is desired. 
Supercedes value for \code{pert_iname} specified in \code{where_clause} 
(if any).}

\item{cell_line}{name (cell_id) of cell line for which data is desired.
Supercedes value for \code{cell_id} specified in \code{where_clause} 
(if any).}

\item{type}{Optional type (pert_type) of perturbation for which data is desired, 
should be one of \code{c("trt_cp", "trt_sh", "trt_oe")} 
or NULL (default)}

\item{where_clause}{Rather than specifying above terms, an explicit
where_clause may be provided to identify the data to be loaded from
the gctx file.  This will be passed directly the the 
\href{https://clue.io/API#perts}{/pert} endpoint of 
the clue.io API, and full documentation of the query options can be 
reviewed at the above link.}

\item{gold}{Should we limit to instances classified as "gold" by the L1000
project (by virtue of their low inter-replicate variability)?  Default 
is \code{TRUE}.}

\item{inferred}{Should the inferred (non-landmark) genes be
included in the analysis? Default is TRUE. Ignored if index is
specified.}

\item{fields}{Fields to include in the expression set's
phenodata. Default is all available.}

\item{controls}{Should same-plate controls be identified and
included?  Default is FALSE.}

\item{cl}{Optional cluster object to speed up data retrieval from clue.io.
Please use caution...a large cluster might produce requests to the 
API at an obnoxious rate.}

\item{verbose}{Do you want to know how things are going?
Default is FALSE}
}
\value{
Object of type 
    \code{\link{SummarizedExperiment}} containing 
    expression and meta data.
    #' @name loadL1K
}
\description{
Convert data from gctx file to SummarizedExperiment, pulling metadata 
    from various sources.  Specifying the subset of data you want can be 
    done is various ways.  The simplest example is 
    with explicit subsetting 
    (e.g. \code{data <- loadL1K(sl[1:978, 1:10])}, which is equivalent to 
    \code{data <- as(sl[1:978, 1:10], "SummarizedExperiment")}).  However, 
    more sophisticated data loading can be achieved, for example by 
    specifing a specific perturbagen (\code{pert}), or even an explicit 
    \code{where_clause} which will be passed directly to the clue.io API. 
    Thus, this function supports users with varying degrees of familiarity 
    with the structure and content of the L1000 metadata.  All arguments 
    are optional.
}
\examples{

# for build/demo only.  You MUST use your own key when using the slinky
# package.
user_key <- httr::content(httr::GET('https://api.clue.io/temp_api_key'),
                          as='parsed')$user_key
sl <- Slinky(user_key,
                 system.file('extdata', 'demo.gctx',
                      package='slinky'),
                 system.file('extdata', 'demo_inst_info.txt',
                     package = 'slinky'))
amox_gold <- clueInstances(sl, where_clause = list("pert_type" = "trt_cp",
                                                  "pert_iname" = "amoxicillin",
                                                  "cell_id" = "MCF7",
                                                  "is_gold" = TRUE), 
                          poscon = "omit")
ids.ctrl <- controls(sl, ids = amox_gold)$distil_id
amox_and_control <- loadL1K(sl, ids = c(amox_gold, 
                                       ids.ctrl))
str(SummarizedExperiment::assays(amox_and_control)[[1]]) 
                                      
}
